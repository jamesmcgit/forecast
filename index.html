<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ISO Daily Peaks — 30-Day Lookback & Forecast</title>
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
    body { margin: 16px; }
    h1 { margin: 0 0 8px; font-size: 1.5rem; }
    .toolbar { display:flex; gap:8px; flex-wrap: wrap; align-items:center; margin-bottom: 12px; }
    .toolbar a, .toolbar button { padding: 8px 10px; border-radius: 8px; border: 1px solid #ddd; background: #fafafa; cursor: pointer; text-decoration:none; }
    .toolbar button:hover, .toolbar a:hover { background: #f0f0f0; }
    .small { font-size: .9rem; color:#555; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 18px; }
    .card { border: 1px solid #e6e6e6; border-radius: 12px; padding: 12px; background:white; }
    .card h2 { margin: 0 0 4px; font-size: 1.1rem; }
    .meta { display:flex; gap:12px; flex-wrap:wrap; font-size:.9rem; color:#444; margin-bottom: 8px; }
    .diag { margin-top: 14px; padding: 12px; border:1px dashed #ddd; border-radius: 10px; background:#fcfcfc; }
    .ok { color: #157347; }
    .bad { color: #b00020; }
    canvas { width: 100%; height: 260px; }
  </style>
  <!-- Chart.js (defer so DOM is ready first) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js" defer></script>
  <script defer>
  // ---------- Utilities ----------
  const tz = 'America/Los_Angeles';

  // Make URL paths safe for GitHub Project Pages subpaths (e.g., /forecast/)
  const urlFor = (p) => {
    const basePath = window.location.pathname.endsWith('/')
      ? window.location.pathname
      : window.location.pathname.replace(/[^/]*$/, '');
    const rel = p.startsWith('./') ? p : `./${p}`;
    return new URL(rel, `${window.location.origin}${basePath}`).toString();
  };

  const fmtTime = (d) => new Intl.DateTimeFormat('en-US', {
    timeZone: tz, hour: '2-digit', minute: '2-digit'
  }).format(d);

  const fmtDateTime = (d) => new Intl.DateTimeFormat('en-US', {
    timeZone: tz, year:'numeric', month:'short', day:'2-digit',
    hour:'2-digit', minute:'2-digit'
  }).format(d);

  async function fetchJSONSafe(path) {
    const url = urlFor(path);
    try {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return await r.json();
    } catch (e) {
      console.warn('fetchJSONSafe error', path, e);
      return { __error: e.message || String(e) };
    }
  }

  // ---------- App Config ----------
  // Add/remove ISOs here. Keep filenames exactly as on disk under /data/
  const isoConfigs = [
    { id: 'CAISO', label: 'CAISO', hist: 'data/CAISO_hist.json', fcst: 'data/CAISO_fcst.json' },
    { id: 'PGE',   label: 'PG&E',  hist: 'data/PGE_hist.json',   fcst: 'data/PGE_fcst.json'   },
    { id: 'SCE',   label: 'SCE',   hist: 'data/SCE_hist.json',   fcst: 'data/SCE_fcst.json'   },
    { id: 'SDGE',  label: 'SDG&E', hist: 'data/SDGE_hist.json',  fcst: 'data/SDGE_fcst.json'  },
    // Add more as needed...
  ];

  // Keep Chart.js instances to safely destroy before re-render
  const charts = {};

  function renderLineChart(canvasId, labels, histSeries, fcstSeries) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return console.warn('Missing canvas', canvasId);
    const ctx = canvas.getContext('2d');
    if (charts[canvasId]) charts[canvasId].destroy();

    charts[canvasId] = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          { label: 'History', data: histSeries, tension: 0.25, pointRadius: 0 },
          { label: 'Forecast', data: fcstSeries, tension: 0.25, pointRadius: 0, borderDash: [6, 4] }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { position: 'bottom' },
          title: { display: false },
          tooltip: {
            callbacks: {
              title(items) {
                // labels already Date objects formatted below
                return items?.[0]?.label ?? '';
              }
            }
          }
        },
        scales: {
          x: { ticks: { maxRotation: 0, autoSkip: true } },
          y: { beginAtZero: false }
        }
      }
    });
  }

  function coerceTimeSeries(raw) {
    // Accepts arrays of objects like { timestamp, value } or { time, val } or pairs [t, v]
    if (!Array.isArray(raw)) return [];
    const out = [];
    for (const d of raw) {
      let t, v;
      if (Array.isArray(d) && d.length >= 2) { t = d[0]; v = d[1]; }
      else if (d && typeof d === 'object') {
        t = d.timestamp ?? d.time ?? d.t ?? d.date;
        v = d.value ?? d.val ?? d.y ?? d.load ?? d.demand;
      }
      const dt = new Date(t);
      const val = Number(v);
      if (!isNaN(dt) && isFinite(val)) out.push({ t: dt, v: val });
    }
    // sort just in case
    out.sort((a,b) => a.t - b.t);
    return out;
  }

  function mergeLabels(hist, fcst) {
    const map = new Map();
    for (const x of hist) map.set(+x.t, x.t);
    for (const x of fcst) map.set(+x.t, x.t);
    return Array.from(map.values()).sort((a,b)=>a-b);
  }

  function seriesToArray(labels, series) {
    const idx = new Map(series.map(d => [+d.t, d.v]));
    return labels.map(t => idx.get(+t) ?? null);
  }

  function findPeakHourLocal(series) {
    if (!series.length) return null;
    let best = null;
    for (const d of series) {
      if (d == null) continue;
      if (best == null || d.v > best.v) best = d;
    }
    return best ? fmtDateTime(best.t) : null;
  }

  async function loadISO(iso) {
    const card = document.getElementById(`card-${iso.id}`);
    const peak = card?.querySelector('.peak');
    const last = document.getElementById('last-update');
    if (!card) return;

    const [histRaw, fcstRaw] = await Promise.all([
      fetchJSONSafe(iso.hist),
      fetchJSONSafe(iso.fcst)
    ]);

    // Error badges (don’t throw; render what we can)
    const errs = [];
    if (histRaw?.__error) errs.push(`Hist: ${histRaw.__error}`);
    if (fcstRaw?.__error) errs.push(`Fcst: ${fcstRaw.__error}`);
    const errBox = card.querySelector('.errors');
    if (errBox) errBox.textContent = errs.join(' | ');

    const hist = coerceTimeSeries(histRaw?.series ?? histRaw);
    const fcst = coerceTimeSeries(fcstRaw?.series ?? fcstRaw);

    // Labels (Date objects) and formatted strings for x-axis
    const labelsDates = mergeLabels(hist, fcst);
    const labels = labelsDates.map(d => new Intl.DateTimeFormat('en-US', {
      timeZone: tz, month: 'short', day: '2-digit', hour: '2-digit'
    }).format(d));

    const histArr = seriesToArray(labelsDates, hist);
    const fcstArr = seriesToArray(labelsDates, fcst);

    const canvasId = `chart-${iso.id}`;
    if (!labels.length || (!histArr.some(n=>n!=null) && !fcstArr.some(n=>n!=null))) {
      // No data; clear old chart if any
      if (charts[canvasId]) { charts[canvasId].destroy(); delete charts[canvasId]; }
      const empty = card.querySelector('.empty');
      if (empty) empty.textContent = 'No data available.';
      if (peak) peak.textContent = '—';
      return;
    }

    // Peak hour from forecast if available, else history
    const fcstPairs = (coerceTimeSeries(fcstRaw?.series ?? fcstRaw));
    const histPairs = (coerceTimeSeries(histRaw?.series ?? histRaw));
    const peakWhen = findPeakHourLocal(fcstPairs.length ? fcstPairs : histPairs);
    if (peak) peak.textContent = peakWhen ?? '—';

    renderLineChart(canvasId, labels, histArr, fcstArr);

    if (last) last.textContent = fmtDateTime(new Date());
  }

  async function checkFiles() {
    const box = document.getElementById('diag');
    if (!box) return;
    box.innerHTML = '<div class="small">Checking files…</div>';
    const files = [];
    for (const iso of isoConfigs) { files.push(iso.hist, iso.fcst); }

    const rows = [];
    for (const f of files) {
      const url = urlFor(f);
      try {
        const r = await fetch(url, { cache: 'no-store' });
        rows.push(`<div>${f}: ${r.ok ? '<span class="ok">OK</span>' : `<span class="bad">${r.status}</span>`}</div>`);
      } catch(e) {
        rows.push(`<div>${f}: <span class="bad">ERROR (${e.message})</span></div>`);
      }
    }
    box.innerHTML = rows.join('');
  }

  async function init() {
    // Build cards
    const grid = document.getElementById('grid');
    if (!grid) return;

    grid.innerHTML = isoConfigs.map(iso => `
      <div class="card" id="card-${iso.id}">
        <h2>${iso.label}</h2>
        <div class="meta">
          <div>Predicted peak (local): <strong class="peak">—</strong></div>
          <div class="errors bad"></div>
          <div class="empty small"></div>
        </div>
        <canvas id="chart-${iso.id}" aria-label="${iso.label} load chart"></canvas>
      </div>
    `).join('');

    // Load all ISOs
    await Promise.allSettled(isoConfigs.map(loadISO));
  }

  // ---------- Wire up UI ----------
  document.addEventListener('DOMContentLoaded', () => {
    const refreshBtn = document.getElementById('refresh');
    const diagBtn = document.getElementById('run-diag');
    const last = document.getElementById('last-update');

    if (refreshBtn) refreshBtn.addEventListener('click', init);
    if (diagBtn) diagBtn.addEventListener('click', checkFiles);

    if (last) last.textContent = '—';
    init();
  });
  </script>
</head>
<body>
  <h1>ISO Daily Peaks — 30-Day Lookback & Forecast</h1>
  <div class="toolbar">
    <button id="refresh" type="button">Refresh now</button>
    <button id="run-diag" type="button">Run file checks</button>
    <a href="https://github.com/jamesmcgit/forecast" target="_blank" rel="noopener">Repo</a>
    <span class="small">Last updated: <span id="last-update">—</span></span>
  </div>

  <div class="grid" id="grid" aria-live="polite"></div>

  <div class="diag" id="diag" aria-live="polite">
    <div class="small">Diagnostics will appear here.</div>
  </div>
</body>
</html>
